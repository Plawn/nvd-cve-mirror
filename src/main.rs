use atomic_counter::{AtomicCounter, RelaxedCounter};
use mongodb::{bson::doc, options::ClientOptions, Client};
// use chrono::{DateTime, Utc};
use futures::stream::StreamExt;
use serde::{Deserialize, Serialize};
use tokio::fs::File;
use clap::Parser;

use tokio::io::AsyncWriteExt; // for write_all()

pub mod chrono_datetime_as_bson_datetime {
    use bson::DateTime;
    use serde::ser;
    use serde::{Deserialize, Deserializer, Serializer};
    use std::result::Result;
    // use std::result::Result;

    pub fn deserialize<'de, D>(deserializer: D) -> Result<DateTime, D::Error>
    where
        D: Deserializer<'de>,
    {
        return DateTime::deserialize(deserializer);
    }

    /// Serializes a [`crate::DateTime`] as an RFC 3339 (ISO 8601) formatted string.
    pub fn serialize<S: Serializer>(val: &DateTime, serializer: S) -> Result<S::Ok, S::Error> {
        let formatted = val
            .try_to_rfc3339_string()
            .map_err(|e| ser::Error::custom(format!("cannot format {} as RFC 3339: {}", val, e)))?;
        serializer.serialize_str(&formatted)
    }
}

#[derive(Deserialize, Debug, Serialize)]
struct Access {
    authentication: Option<String>,
    complexity: Option<String>,
    vector: Option<String>,
}

#[derive(Deserialize, Debug, Serialize)]
struct Impact {
    availability: Option<String>,
    confidentiality: Option<String>,
    integrity: Option<String>,
}
///     #[serde(with = "chrono_datetime_as_bson_datetime")]
///     pub date: chrono::DateTime<chrono::Utc>,
#[derive(Deserialize, Debug, Serialize)]
struct CVE {
    id: String,
    assigner: String,

    #[serde(rename = "Published")]
    #[serde(with = "chrono_datetime_as_bson_datetime")]
    published: bson::DateTime,

    #[serde(with = "chrono_datetime_as_bson_datetime")]
    #[serde(rename = "Modified")]
    modified: bson::DateTime,

    #[serde(with = "chrono_datetime_as_bson_datetime")]
    #[serde(rename = "last-modified")]
    last_modified: bson::DateTime,

    summary: Option<String>,
    access: Option<Access>,
    impact: Option<Impact>,
    // cvss3: null,
    cvss: Option<f32>,

    #[serde(rename = "exploitabilityScore")]
    exploitability_score: Option<f32>,

    #[serde(rename = "impactScore")]
    impact_score: Option<f32>,
    // #[serde(rename = "'cvss-time'")]
    // 'cvss-time': ISODate('2019-04-30T14:27:00.000Z'),
    #[serde(rename = "cvss-vector")]
    cvss_vector: Option<String>,
    references: Vec<String>,
    vulnerable_configuration: Vec<String>,
    vulnerable_product: Vec<String>,
    vendors: Vec<String>,
    products: Vec<String>,
    vulnerable_product_stems: Vec<String>,
    vulnerable_configuration_stems: Vec<String>,
    cwe: Option<String>,
    vulnerable_configuration_cpe_2_2: Vec<String>,
}

 
#[derive(Parser)]
struct Cli {
    /// The folder to put the cves in
    #[arg(short, long)]
    folder: String,
    /// The name of the db in the mongoDB
    #[arg(short, long)]
    db_name: String,
    /// URI of the mongodb, starting with "mongodb://"
    #[arg(short, long)]
    mongo_uri: String,
    /// Name of the cve collection
    #[arg(short, long)]
    cve_collection: String,
}

async fn test_db(db_name: &str, client: &Client) -> mongodb::error::Result<()> {
    client
        .database(db_name)
        .run_command(doc! {"ping": 1}, None)
        .await?;
    println!("Pinged your deployment. You successfully connected to MongoDB!");
    Ok(())
}

#[tokio::main]
async fn main() -> mongodb::error::Result<()> {
    // Replace the placeholder with your Atlas connection string
    let args = Cli::parse();
    let folder = args.folder;
    let db_name = args.db_name;
    let mongo_uri = args.mongo_uri;
    // let cve_collection = "cves";
    let cve_collection = args.cve_collection;
    // let uri = "mongodb://localhost:26000";
    let client_options = ClientOptions::parse(mongo_uri).await?;

    // Create a new client and connect to the server
    let client = Client::with_options(client_options)?;
    // Send a ping to confirm a successful connection
    test_db(&db_name, &client).await?;

    let counter = RelaxedCounter::new(0);
    let cves = client.database(&db_name.as_str()).collection::<CVE>(&cve_collection);
    let cursor = cves.find(None, None).await?; // find all
    
    cursor
        .for_each_concurrent(100, |raw_cve| async {
            let cve = raw_cve.expect("failed to parse");
            let mut file = File::create(format!("{}/{}.json", &folder, &cve.id))
                .await
                .expect("failed to use file");
            file.write_all(
                serde_json::to_string_pretty(&cve)
                    .expect("failed to convert to json")
                    .as_bytes(),
            )
            .await
            .expect("failed to write to file");
            counter.inc();
            // let val = counter.get();
            if counter.get() % 1000 == 0 {
                println!("{}", counter.get());
            }
        })
        .await;

    return Ok(());
}
